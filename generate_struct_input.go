package main

import (
	"fmt"
	"log"
	"os"
	"path/filepath"
	"reflect"
	"strings"
	"time"

	"github.com/ekokurniadi/indodate"
	"github.com/fatih/camelcase"
)

func CreateStructInput(mystruct interface{}) string {
	createFolder()
	createFile(mystruct)
	writeFile(mystruct)
	if nameOfStruct := reflect.TypeOf(mystruct); nameOfStruct.Kind() == reflect.Ptr {
		return "*" + nameOfStruct.Elem().Name()
	} else {
		return nameOfStruct.Name()
	}

}

func writeFile(mystruct interface{}) (string, error) {

	name := ""
	if nameOfStruct := reflect.TypeOf(mystruct); nameOfStruct.Kind() == reflect.Ptr {
		name = nameOfStruct.Elem().Name()
	} else {
		name = nameOfStruct.Name()
	}

	filepath, err := filepath.Abs("./input" + "/" + strings.ToLower(name) + ".go")
	if err != nil {
		log.Fatal("error")
		return filepath, err
	}

	file, err := os.OpenFile(filepath, os.O_RDWR, 0644)
	if isError(err) {
		return "", err
	}
	defer file.Close()

	//Write some text line-by-line to file.
	_, err = file.WriteString("package input")
	if isError(err) {
		return "", err
	}
	_, err = file.WriteString(fmt.Sprintf("%s%s", "\n", "\n"))
	if isError(err) {
		return "", err
	}

	_, err = file.WriteString(fmt.Sprintf("type %s %s %s", "InputID"+name, "struct {", "\n"))
	if isError(err) {
		return "", err
	}

	val := reflect.ValueOf(mystruct).Elem()
	for i := 0; i < val.NumField(); i++ {
		if val.Type().Field(i).Name == "ID" {
			fmt.Print("Writting ... ")
			var camelCase_formatter []string

			splitted := camelcase.Split(val.Type().Field(i).Name)
			for a := 0; a < len(splitted); a++ {
				camelCase_formatter = append(camelCase_formatter, strings.ToLower(splitted[a]))
			}
			replaceCamelCase := strings.Join(camelCase_formatter, "_")
			fmt.Printf("%s %s %s%v%s", val.Type().Field(i).Name, val.Type().Field(i).Type, "`uri:\"", replaceCamelCase, "\" binding:\"required\"` \n")
			_, err = file.WriteString(fmt.Sprintf("%s %s %s%v%s", val.Type().Field(i).Name, val.Type().Field(i).Type, "`uri:\"", replaceCamelCase, "\" binding:\"required\"` \n"))
			if isError(err) {
				return "", err
			}
		} else {
			fmt.Println("")
		}
	}

	_, err = file.WriteString("}\n\n")
	if isError(err) {
		return "", err
	}

	_, err = file.WriteString(fmt.Sprintf("type %s %s %s", name+"Input", "struct {", "\n"))
	if isError(err) {
		return "", err
	}

	val = reflect.ValueOf(mystruct).Elem()
	for i := 0; i < val.NumField(); i++ {
		if val.Type().Field(i).Name == "ID" {
			_, err = file.WriteString("")
			if isError(err) {
				return "", err
			}
		} else {
			fmt.Print("Writting ... ")
			var camelCase_formatter []string

			splitted := camelcase.Split(val.Type().Field(i).Name)
			for a := 0; a < len(splitted); a++ {
				camelCase_formatter = append(camelCase_formatter, strings.ToLower(splitted[a]))
			}
			replaceCamelCase := strings.Join(camelCase_formatter, "_")
			fmt.Printf("%s %s %s%v%s", val.Type().Field(i).Name, val.Type().Field(i).Type, "`json:\"", replaceCamelCase, "\"` \n")
			_, err = file.WriteString(fmt.Sprintf("%s %s %s%v%s", val.Type().Field(i).Name, val.Type().Field(i).Type, "`json:\"", replaceCamelCase, "\"` \n"))
			if isError(err) {
				return "", err
			}
		}
	}

	_, err = file.WriteString("}\n\n")
	if isError(err) {
		return "", err
	}

	_, err = file.WriteString(fmt.Sprintf("//Generated by Micagen at %v", indodate.LetterDate(time.Now())))
	if isError(err) {
		return "", err
	}
	// Save file changes.
	err = file.Sync()
	if isError(err) {
		return "", err
	}

	fmt.Printf("Rewrite file is successfully \n")
	return filepath, nil
}

func isError(err error) bool {

	if err != nil {
		fmt.Println(err.Error())
	}
	return (err != nil)
}

func createFile(mystruct interface{}) (string, error) {
	name := ""
	if nameOfStruct := reflect.TypeOf(mystruct); nameOfStruct.Kind() == reflect.Ptr {
		name = nameOfStruct.Elem().Name()
	} else {
		name = nameOfStruct.Name()
	}

	fmt.Println(name)

	filepath, err := filepath.Abs("./input" + "/" + strings.ToLower(name) + ".go")
	if err != nil {
		log.Fatal("error")
		return filepath, err
	}

	filename, err := os.Create(filepath)

	if err != nil {
		log.Fatal("Cannot create a file please check your directory again")
		return filename.Name(), err
	}

	fmt.Printf("Create %s is successfully \n", filename.Name())
	return filepath, nil
}

func createFolder() error {
	path := filepath.Join("./", "input")
	_, err := os.Stat(path)

	if os.IsExist(err) {
		fmt.Println("your directory is already exist but it's ok")
		return err
	}

	err = os.Mkdir(path, 0755)
	if err != nil {
		fmt.Println("your directory is already exist but it's ok")
		return err
	}

	return nil
}
